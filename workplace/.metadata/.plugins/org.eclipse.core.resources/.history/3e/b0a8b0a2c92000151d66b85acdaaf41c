package org.DAO.Spring.DAOServices;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.DAO.Spring.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Component;

@Component
public class JdbcService {
	
	DataSource dataSource; 
	//using Spring provided DataSource that is defined in spring.xml as a bean with all the connection properties to reduce the boilerplate codes.
	
	JdbcTemplate jdbcTemplate = new JdbcTemplate();
	// here JdbcTemplaet of springframework is used for the purpose of reducing the boilerplate codes as much as possible, this class self executes all the fetching and executing of query and return a specific result as the developer ask it to.
	
	public DataSource getDataSource() {
		return dataSource;
	}

	@Autowired //we autowired the setter as we want the setter to run as the bean initializes at any instance.
	public void setDataSource(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate(dataSource); 
		//  here as we know that the jdbcTemplate need the dataSource as it is implemented, so the dadaSource is set here for it as the dataSource is Autowired implemented.
		//it takes dataSource itself as a constructor parameter and executes a connection.
		this.dataSource = dataSource;
	}

	
	public User getUserByID(int id){
		Connection con = null;
		User user = null;
		try{
		con = dataSource.getConnection(); //using dataSource to create connections.
		PreparedStatement ps = con.prepareStatement("select * from spring_dao where u_id=?");
		ps.setInt(1, id);
		ResultSet rs = ps.executeQuery();
		rs.next();
		user = new User(id,rs.getString("u_name"));
		rs.close();
		ps.close();
		}catch(Exception e){throw new RuntimeException(e);}
		finally{try {
			con.close();
		} catch (SQLException e) {}
		
		}
		return user;
	}
	
	
	public String getUser_usingJDBCtemp(int id){
		return (String) jdbcTemplate.queryForObject("select u_name from spring_dao where u_id=? ", new Object[] {1}, String.class);
		//now here we used another JdbcTemplate constructor to execute query and give back an object , also we provided the args of the statement, it will fill that up,
		//and then we mentioned the object true class to which we want it to be casted.
		//eclipse isnt casting it properly, so i casted it myself too. :)
	}
	
	public int userCount(){
		
		return jdbcTemplate.queryForInt("select count(*) from spring_dao"); //here we used the jdbcTemplate to execute our query and return the value in the form of a Int, 
		//after bein implemented when the dataSource is gotten(getDataSource();)
	}

	public User getUser_ObjectMapped(int uid){
		
	}
	
	
	private static final class UserMapper implements RowMapper{
		// to create an JdbcTemplate that returns an object as an returntype, we need to implement RowMapper and use the implemented classes maprow() as to map all the rows of our table to the object member variables.
		
		@Override
		public User mapRow(ResultSet resultset, int rownum) throws SQLException {
		
			User user = new User();
			user.setUid(resultset.getInt("u_id"));
			user.setUname(resultset.getString("u_name"));
			return user;
		}
		
	}
}
